**Terraform Fundamentals**

1\.



 Terraform היא כלי בקוד פתוח המאפשר לנהל תשתיות (שרתים, רשתות, בסיסי נתונים) באמצעות קוד , במקום להקליק ידנית בפורטלים כמו AWS או Azure, כותבים קובץ הגדרות והכלי בונה הכל בשבילך.



במה היא שונה

\- עבודה מול ספקים מרובים

\- גישה דקלרטיבית: אתה מגדיר מה אתה רוצה לקבל, והיא מחליטה איך לבצע את זה

-ניהול מצב (State) : ה-State הוא קובץ (JSON) שמהווה את הזיכרון של Terraform הוא מבטיח שאם תריץ את הקוד שוב, Terraform לא תנסה ליצור הכל מאפס, אלא רק תשלים את מה שחסר בנוסף הוא מאפשר ל-Terraform לדעת מה המצב הקיים בשטח לעומת מה שביקשת בקוד, וכך להחליט אם ליצור, לעדכן או למחוק.



2\.



דקלרטיבי (הצהרתי) - אתה לא כותב "תלחץ על הכפתור ותוסיף שרת", אתה כותב "אני רוצה שיהיו 3 שרתים". אם כבר יש 2, טרהפורם תבין לבד שהיא צריכה להוסיף רק אחד. אם יש 4, היא תמחוק אחד.



ניהול מצב (State Management): טרהפורם שומרת קובץ (בדרך כלל terraform.tfstate) שמהווה "מקור אמת". הקובץ הזה ממפה את המשאבים שמוגדרים בקוד שלך אל מול המשאבים שקיימים בפועל בענן.

זה עוזר לה להבין אילו שינויים נדרשים בכל פעם שמריצים אותה.



3\.



ה-Provider (ספק) הוא ה"מתרגם" של טרהפורם. מכיוון שטרהפורם היא כלי גנרי, היא צריכה דרך לדבר עם שירותים ספציפיים.

\- הפרוביידר (למשל של AWS או Google Cloud) מכיל את הלוגיקה שממירה את קוד הטרהפורם לקריאות API שהענן מבין.

\*\*\* בלי פרוביידר, טרהפורם לא תדע איך ליצור שום דבר.



4\.



אתה כותב את המשאבים, טרהפורם מחשבת את הסדר

\- תלות משתמעת (Implicit Dependency):  אם משאב א' משתמש במידע ממשאב ב', טרהפורם מבינה לבד שצריך ליצור קודם את ב'.

\- תלות מפורשת (Explicit Dependency): משתמשים ב-depends\_on (  הוראה שבה אתה אומר לטרהפורם: "אל תיגע במשאב הזה עד שמשאב אחר יסיים לעבוד") כשרוצים לקבוע סדר באופן ידני (כשאין קשר ישיר בקוד).

\- ביצוע במקביל (Parallelism): כל מה שלא תלוי אחד בשני – נוצר במקביל כדי לחסוך זמן.



5\.



Provider - זהו המרכיב שמסביר לטרהפורם עם איזה "ענן" או שירות היא הולכת לדבר (למשל AWS, Google Cloud, Azure).

מה הוא עושה: מגדיר את ההגדרות הבסיסיות כמו האזור (Region) או פרטי התחברות.



Resources - זה הלב של הקוד כאן מגדירים את התשתית הפיזית/וירטואלית שאתם רוצים ליצור.

מה הוא עושה: יוצר שרתים, מסדי נתונים, רשתות וכו'.



Variables - כמו בכל שפת תכנות, משתנים מאפשרים לנו להפוך את הקוד לדינמי וגמיש מבלי "לנעול" ערכים קבועים (Hardcoded).

מה הוא עושה: מאפשר לשנות הגדרות (כמו גודל השרת) מבלי לגעת בקוד המרכזי.



Outputs - לאחר שהתשתית נוצרה, לעיתים נרצה לקבל מידע חזרה.

מה הוא עושה: מדפיס למסך מידע כמו כתובת ה-IP של השרת שזה עתה נוצר.



Data Sources - מאפשרת לנו לשאוב מידע מתשתית שכבר קיימת בענן (ולא נוצרה על ידי הקוד הנוכחי שלנו).

מה הוא עושה: "לך תבדוק מה ה-ID של הרשת הקיימת בארגון שלי".



**State Management \& Backend Configuration**



6\.



terraform plan (התכנון) -

משווה בין הקוד שכתבת לבין המצב הקיים בענן ומציג לך דו"ח: מה יתווסף (+), מה ישתנה (~), ומה יימחק (-).



terraform apply (הביצוע) -

שולחת פקודות לענן (AWS, Azure וכו') כדי ליצור או לעדכן את המשאבים. בסיום, היא מעדכנת את קובץ ה-State (הזיכרון של טרהפורם).



terraform refresh (העדכון) -

פקודה זו הולכת לענן ובודקת אם נעשו שינויים ידניים (מחוץ לטרהפורם). היא מעדכנת את קובץ ה-State המקומי כדי שיהיה מתואם עם המציאות.



7\.



Local Backend -

הקובץ נשמר על המחשב האישי שלך.

מתאים ללמידה או לפרויקטים קטנים של אדם אחד.

Remote Backend -

הקובץ נשמר בענן (כמו ב-S3, Azure Storage או Terraform Cloud).

מתאים לעבודה בצוות

\*\*\* בשורה התחתונה: Local זה לניסויים בבית, Remote זה לעבודה אמיתית בצוות.



8\.



כשעובדים בצוות, הבעיה העיקרית היא ששני אנשים עלולים להריץ terraform apply בו-זמנית ולדרוס זה לזה את ה-"זיכרון" של המערכת (קובץ ה-State).

פתרון לבעיה



-אחסון מרוחק (Remote Backend) : במקום לשמור את קובץ ה-State על המחשב האישי של כל מהנדס (מה שיוצר חוסר סנכרון), שומרים אותו במקום מרכזי בענן (כמו S3 של AWS). כך כולם תמיד עובדים מול אותה גרסה.



-נעילת מצב (State Locking) : זהו המנגנון הקריטי למניעת התנגשויות. כאשר מהנדס אחד מריץ apply, טרהפורם "נועלת" את קובץ ה-State כך שם מהנדס אחר ינסה להריץ פקודה באותו זמן, הוא יקבל הודעת שגיאה שהקובץ נעול.



**Terraform Modules \& Reusability**



9\. 



בקיצור נמרץ, מודולים הם הדרך של Terraform לארוז קוד ליחידות קטנות ושימושיות (ממש כמו פונקציות בתכנות).

היתרונות
- שימוש חוזר בקוד (Reusability) : במקום לכתוב את אותן הגדרות שרת שוב ושוב, כותבים מודול פעם אחת ומשתמשים בו בכל הפרויקטים.
- סדר וארגון : מחלקים תשתית ענקית ומסובכת לחלקים קטנים, מובנים וקלים לניהול.
- תחזוקה קלה: אם צריך לעדכן משהו מעדכנים במקום אחד (במודול) וזה משתקף בכל המקומות שמשתמשים בו.
- בידוד: שינוי במודול אחד לא משפיע על שאר התשתית בצורה לא מבוקרת.
בשורה התחתונה: מודולים הופכים את התשתית שלך מ"ערימת קוד" למערכת חכמה, מסודרת וניתנת לשכפול.



10\.

התהליך מורכב משני שלבים פשוטים:
- בתוך קובץ המודול (לרוב בקובץ שנקרא variables.tf), אתה מגדיר אילו משתנים המודול מוכן לקבל.

-כשאתה קורא למודול מהקוד הראשי שלך (main.tf), אתה "מזין" את הערך לתוך המשתנה שהגדרת קודם. זה השלב שבו המודול מקבל את התוכן האמיתי שלו.



11\.


ההבדלים בתמצית, שניהם משמשים ליצירת מספר מופעים של משאב (Resource), אבל הם עובדים בצורה שונה ומתאימים למקרים שונים.
count - כשיוצרים מכונות זהות לגמרי  

for\_each - כשיוצרים משאבים על בסיס רשימת שמות או נתונים משתנים.
\*\*לסיכום : אם אתה צריך שכפול פשוט של משהו זמני - count יכול להועיל מאוד , אם אתה בונה תשתית רצינית שצריכה להשתנות לאורך זמן - תמיד עדיף for\_each.

12.



ב-Terraform, במקום להשתמש בנתיב מקומי (Local path), אנחנו פשוט מגדירים את הכתובת של ה-Repository בשדה ה-source.
ניתן להשתמש בכתובת HTTPS או SSH. הקידומת git:: אומרת ל-Terraform להתייחס לכתובת כמאגר Git.


**Terraform with AWS**



13\. כדי ליצור שרת EC2 ב-AWS, אנחנו צריכים להגדיר שני דברים עיקריים: ה-Provider (החיבור ל-AWS) וה-Resource (הגדרות השרת עצמו).
כמו כן נשתמש בפקודות שלבי הרצה terraform init , terraform plan , terraform apply .

הגדרת Provider ו-Resource היא הדרך המהירה ביותר להקים תשתית.

14. 



כדי להקים VPC בסיסי ב-AWS באמצעות Terraform, יש רק שדה חובה אחד שחייבים להגדיר.

cidr\_block : השדה cidr\_block הוא השדה היחיד שבלעדיו ה-Resource לא יעבוד. הוא קובע את טווח כתובות ה-IP של הרשת . 
למרות שרק ה-CIDR הוא חובה, ברוב המקרים תרצה להשתמש גם בשדות הבאים: 
tags: מומלץ מאוד להוסיף תגית Name כדי שתוכל לזהות את ה-VPC בקונסול של AWS.
enable\_dns\_hostnames: אם תרצה שהמכונות בתוך ה-VPC יקבלו שמות DNS ציבוריים (מוגדר כ-false כברירת מחדל).



15\.

בקיצור רב, Terraform מנהלת הרשאות ב-AWS על ידי הגדרת המשאבים כקוד (HCL), תוך שימוש בשלושה רכיבים עיקריים שמתחברים זה לזה:
- The Resource : מגדירים את ה"ישות" לה רוצים לתת הרשאות, כמו User (משתמש), Group (קבוצה) או Role (תפקיד).

\-The Policy : מגדירים מה מותר לעשות. ב-Terraform יש שתי דרכים עיקריות לכתוב זאת JSON ו - Data Source

\-The Attachment : זהו השלב הקריטי  Terraform משתמשת במשאבי "קישור" (כמו aws\_iam\_role\_policy\_attachment) כדי להדביק את המדיניות (ה-Policy) לישות (ה-Role/User).

16.


בעבודה עם AWS ו-Terraform, התהליך מורכב בדרך כלל משלושה שלבים: יצירת מאזן העומסים (ה-LB), יצירת קבוצת יעד (Target Group), וחיבור השרתים (Instances) אליה.
כיום מומלץ להשתמש ב-Application Load Balancer (ALB).


**Debugging \& Error Handling**


17. 



הפקודה בודקת האם הקוד שכתבת תקין מבחינה תחבירית  ולוגית, בלי להתחשב במצב המשאבים בענן.
תחביר (Syntax): סוגריים, מרכאות או פסיקים 
שמות משתנים : שימוש משתנה (Variable) שלא הגדרת
סוגי נתונים : האם הוזן למשאב מספר (Integer) במקום מחרוזת (String)

קיום מודולים: האם חסרים מודולים שקראת להם אך לא הורדו
דוגמא לפקודה שנלמדה בשיעור - terraform fmt


18.

כשמשהו משתבש ב-Terraform, יש כמה כלים ושיטות שמאפשרים להבין בדיוק איפה הבעיה
terraform validate - לפני שמנסים להריץ, הפקודה הזו בודקת את תחביר הקוד (Syntax). היא תגיד לך אם שכחת סוגריים, אם חסר משתנה חובה או אם יש טעות בשם של משאב.
terraform plan - זהו שלב חשוש שמראה לך מה Terraform עומדת לעשות לפני שהיא עושה זאת בפועל.

terraform console - זהו כלי אינטראקטיבי שמאפשר לך לבדוק ביטויים, משתנים ופונקציות בזמן אמת בלי להקים תשתית.

בדיקת קובץ ה-State - לפעמים הבעיה היא שה-Terraform "חושבת" שמשהו קיים בעוד שהוא לא (או להפך) שימוש ב-terraform show או terraform state list עוזר להבין מה המצב הנוכחי שהמערכת מכירה.



19\.



בקיצור רב, ignore\_changes משמש כדי להגיד ל-Terraform: "אל תתייחסי לשינויים במאפיינים ספציפיים של המשאב הזה, גם אם הם שונים ממה שכתוב בקוד".



20\.



התהליך נקרא Terraform Import והוא נועד למצבים בהם הקמת משאבים ידנית (דרך ה-Console) ואתה רוצה ש-Terraform תתחיל לנהל אותם כקוד.

התהליך מורכב משלושה שלבים עיקריים:
-כתיבת הקוד (The Configuration) : עליך לכתוב ב-Terraform בלוק resource ריק שמתאים לסוג המשאב שאתה רוצה לייבא.

-הרצת פקודת ה-Import : משתמשים בפקודה terraform import 
\*\*\* לאחר הרצת הפקודה terraform import צריך לספק את המזהה של המשאב בתוך הקוד ובנוסף המזהה האמיתי של המשאב ב-AWS (כמו Instance ID או שם ה-Bucket).

-סנכרון הקוד (Matching) : הפקודה terraform plan מייבאת את המידע רק לקובץ ה-State (הזיכרון של טרפורם), היא לא כותבת עבורך את הקוד בתיקייה כלומר אם חסרים נתונים בקוד שכתבת, טרפורם תציג לך את ההבדלים. עליך לעדכן את הקוד עד ש-plan יראה שהכל תואם ("No changes").



